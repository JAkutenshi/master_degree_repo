Результатом выполнения бенчмарк-тестирования является множество json-файлов (не менее одного), в которых записаны результаты тестирования. Для автоматизации обработки множества результатов тестирования, а так же их визуализации была реализована программа, которая обрабатывает все указанные json-файлы c результатами и формирует отчет с таблицами и графиками результатов тестирования в формате rmarkdown. Исходный код программы представлен в приложении \ref{application:analyser}. 

Обработку результатов можно разбить на следующие итерации:
\begin{enumerate}
	\item Анализ файла конфигурации \inline{merge_config.xml} и формирование промежуточного файла \inline{full.json}, содержащего список всех бенчмарк-тестов со всеми полученными значениями измерений.
	
	Исходные json-файлы можно разделить на два типа: первичные и вторичные.
	
	\begin{description}[noitemsep]
		\item [Первичный] -- это json-файл, полученный исполнением непосредственно Google Benchmark исполняемого модуля. В данном json-файле располагается список \inline{benchmarks} c описанием данных каждого проведенного теста в формате \enquote{ключ-значение}. Наиболее важные поля:
		\begin{itemize}[noitemsep]
			\item \inline{name} -- название теста с возможными суффиксами \enquote{\_mean}, \enquote{\_stddev} и \enquote{\_median}. Суффиксы добавляются средствами Google Benchmark, если указан ключ для повторений тестов и означают соответственно среднеарифметическое результатов, среднеквадратическое отклонение и медианное значение. Поскольку анализ данных будет производиться отдельно, то записи, содержащие в имени данные суффиксы стоит исключить при обработке.
			
			\item \inline{real_time} -- задержка, основанная на системных часах. При указании замера реального времени, данное значение будет указывать на реальное время в наносекундах, которое было затрачено на выполнение теста.
			
			\item \inline{CPU_time} -- задержка, основанная на количестве циклов процессора. Наиболее точный возможный показатель, но т.к. большинство методов коммуникации в рассматриваемых \marm{} используют технологии многопоточного программирования, данный результат не может считаться адекватным во всех тестах: данный результат требуется рассматривать вместе с задержкой реального времени.
			
			\item \inline{bytes_per_second} -- широта пропускания данных, которое вычисляется на основании количества итераций, количества переданных байтов в отдельный счетчик \inline{SetBytesProcessed()} у объекта типа \inline{benchmark::State} и затраченного реального времени. Результат представляется в количестве байтов в секунду.
			
			\item \inline{bm_id} -- уникальный идентификатор теста. Данное поле задается разработчиком, Google Benchmark не предусматривает никакой автоматической идентификации тестов. Данное поле требуется для связи с результатами производительности полученными на иных узлах связи, отличных от того, на котором работает Google Benchmark.
		\end{itemize}
		
		\item[Вторичный] -- json файл с результатами тестирования полученными каким-то отличным от использования Google Benchmark образом. Например, путем вычисления реальной задержки передачи данных на узлах-получателях. Узел-получатель записывает значения измерений в формате \enquote{измерение-значение}, а для связи с узлом-отправителем, на котором исполняется Google Benchmark, используется уникальный идентификатор теста. В общем случае, не для каждой записи из вторичного json найдется соответствие в первичном, потому что Google Benchmark самостоятельно определяет какие итерации следует пропустить. Как следствие, различие в значениях, полученных во вторичных json-файлах, следует дополнительно объяснять большим количеством переданных сообщений, а так же большим разбросом в значениях. Последнее объясняется тем, что первые итерации измерения производительности скорее-всего не будут адекватными из-за отсутствия часто повторяющихся команд в кэше процессора. Google Benchmark автоматически регулирует количество итераций и набор итераций, которые идут результатом выполнения теста.
	\end{description}
	
	В общем случае, для связи первичного и вторичных json-файлов рекомендуется использовать поле \inline{bm_id}, но так же допускается конфигурирование связи между файлами по другому имени поля.
	
	Исходные json-файлы, их тип и ключ связи для вторичных json-файлах указываются в файле конфигурации \inline{merge_config.xml}. Пример файла конфигурации приведен в приложении \ref{application:config:merge}
	
	Все измерения в найденных по указанному ключу записях из вторичных файлов вставляются в записи первичного json-файла. После слияния первичных json-файлов с соответствующими им вторичными, итоговый файл \inline{full.json} получается путем объединения записей всех первичных json-файлов.
	
	\item Для каждого бенчмарк-теста из списка, полученного на предыдущей итерации, формируется список для бенчарк-тестов без повторений имен (на предыдущей итерации, поскольку тесты могли быть запущены несколько раз, имя записи теста могло повторяться пропорционально количеству запуска тестов) со сгруппированными значениями измерений. Таким образом, сформирована структура данных, которая для каждого набора факторов содержит результаты измерений пропорционально выборке эксперимента. Структура сохраняется в файл \inline{benchmark_processed.json}
	
	\item Далее все результаты статистически обрабатываются: находится среднее значение измерения и среднеквадратичная ошибка среднеарифметического. Результаты записываются в файл \inline{benchmarks_results.json}.
	
	\item Предпоследней итерацией является разбиение результатов, путем получения различных комбинаций тестов, основываясь на определяющих их факторах. Для определения информации о факторах тестирования используется описание факторов в конфигурационном файле первой итерации.
	
	На каждом шаге выбирается переменный фактор, являющийся абсциссой на графиках результатов тестирования. Для всех остальных факторов требуется найти все возможные фиксированные комбинации, относительно которых будет изменяться выбранный переменный фактор.
	
	Таким образом будет сформировано множество таблиц, представляющих зависимость результатов измерений от выбранного переменного фактора и фиксированных остальных.
	
	Результирующий список описания табличных значений записывается в файл \inline{tables.json}.
	
	\item Финальной итерацией является трансляция описаний табличных значений результатов тестирования производительности из файла \inline{tables.json} в rmarkdown файл \inline{result.rmd}. Для конфигурации именования измерений и факторов, а так же описания генерируемых графиков, используется конфигурационный файл \inline{rmd_config.xml}, пример которого представлен в приложении \ref{application:config:rmd}.
\end{enumerate}

Таким образом, было реализовано приложение, принимающее в качестве входных данных множество результатов измерений производительности в формате json, а так же двух конфигурационных файлов с описаниями исходных данных и описанием выходного результата. Результатом работы приложения является rmarkdown-файл, готовый к преобразованию в html страницу при помощи транслятора knit.