\toolchain{} является наиболее сложным \marm{} из всех представленных ранее, т.к. в нем сочетаются все вышеописанные идеи. Первый релиз \toolchain{} в 2006 году, раньше всех исследуемых \marm{}. 

\toolchain{} состоит из нескольких проектов, среди которых нам наиболее важен \rtt{} -- библиотеки для разработки компонентов, загружающихся во время исполнения приложения. Эта же идея используется в MIRA. Компоненты \rtt{} являются наследниками класса \inline{RTT::TaskContext} и переопределяют ряд методов (hooks), определяющих основу поведения RTT-компонента. Данные компоненты являются аналогом узлов ROS или YARP, модулей MIRA. В отличии от MIRA, \orocos{} имеет возможность написания самостоятельных приложений с отдельной точкой входа.

Методов коммуникации в \rtt{} все так же два: система именованных портов для передачи сообщений и вызов удаленных процедур. Разница состоит во множестве способов применять данные инструменты. По доступным возможностям \rtt{} превосходит YARP. Ниже, основываясь на документации разработчиков \cite{rtt-components}, приведено описание методов коммуникации не вдаваясь в подробности API \rtt{}, например, сигналов-событий (Signal event handler) и деятельностей (Activities), которые, расширяют возможности реакции компонентов на внешнюю среду и, как следствие, разные способы вступать в коммуникацию. Тем не менее, эти способы реакции не являются методами передачи сообщений.

\begin{itemize}[noitemsep]
	\item \textit{Именованные порты} -- аналогично портам в YARP, \rtt{} порты реализуют шаблон \enquote{наблюдатель}, где на порты-издатели подписываются порты-подписчики. Разница с YARP в том, что в \rtt{} нет деления на \enquote{обычные} и \enquote{буферизованные} порты, но есть разделение на исходящие \inline{RTT::OutputPort<typename T>} и принимающие порты \inline{RTT::InputPort<typename T>} с соответствующе разными интерфейсами. В то же время, оба типа портов в \rtt{} могут настраивать буферизацию, потокобезопасность и инициализацию соединения пользователем при создании самого соединения.
	
	\item \textit{Вызов удаленных методов} -- аналогично другим \marm{} этот механизм в \orocos{} позволяет вызывать удаленную процедуру, передавая в нее аргументы и получая результат. Вызов удаленных процедур может производиться двумя способами: при помощи непосредственно вызова процедур и при помощи сервисов.
	\begin{description}[noitemsep]
		\item [Вызов операции (operation calling)] отличие главным образом от других подходов в том, что в \orocos это именно процедура, которая может выполняться как в потоке компонента, предоставляющего эту процедуру, так и в потоке клиента, эту процедуру вызывающего. В случае выполнения процедуры в потоке клиента разработчику требуется позаботиться о потокобезопасности разделяемых данных в компоненте клиента. Кроме того, в \rtt{} имеется два подхода к вызову процедур и получению результата: ожидать возврата результата, заблокировав текущий поток выполнения, либо передать ожидание и обработку результата соответствующему объекту-обработчику событий. Последний подход так же требует от разработчика аккуратности при работе с разделяемыми данными, но при этом дает возможность уменьшить реальное (wall clock) время обработки результата.
		\item [Сервисы] отличаются от вызова операций по-сути возможностью именовать сервис, который предоставляет набор операций, которые можно у сервиса вызвать. Это предоставляет возможность компонентам искать другой компонент-сервис по имени во время исполнения приложения.
	\end{description}
\end{itemize}

В \rtt{} могут передаваться любые пользовательские данные. Стандартные типы языка C++ доступны по-умолчанию, но более сложные требуется описать при помощи библиотеки \inline{boost::serialization}.

Особенностью \orocos{} является возможность использования CORBA для передачи данных, а так же возможность использовать в качестве транспорта для внутрипроцессного взаимодействия \inline{MQueue}. Причем CORBA может использовать протокол \todo{OOB (Out-Of-Band)} для передачи данных при помощи механизма MQueue. Это позволяет:
\begin{itemize}[noitemsep]
	\item следить за прерванными соединениями;
	\item быть уверенным, что принимающий поток создается строго после исходящего, а так же корректно закрывает исходящий поток, если не получилось создать принимающий.
\end{itemize}
В целом, совместное использование MQueue и CORBA позволяет добиться большей надежности соединений, но путем затрат ресурсов на инфраструктуру CORBA.

\orocos{} предоставляет создавать объект \enquote{политики соединения} (connection policies) для конфигурирования соединения между портами. В частности, именно в объекте политики соединения указывается транспорт для сообщений. Тем не менее, \orocos{} позиционируется как наилучшее решение для приложений с внутрипроцессным взаимодействием \cite{orocos-interprocess-case}. Для межпроцессного взаимодействия и для передачи данных по сети требуется использовать дополнительные протоколы и подходы, например, CORBA или, например, Qt TCP Sockets.

В отличии от YARP, \toolchain{} не предоставляет возможностей для контроля QoS. На практике, параметры соединений можно изменять, но на уровне конфигурирования транспорта. Политики соединений позволяют лишь указать тип транспорта, размер буфера и \todo{состояние инициализации}.

Таким образом, для производительности \rtt{} важны следующие факторы:
\begin{itemize}[noitemsep]
	\item локализация компонентов: для связи компонентов в разных процессах потребуется использовать другой транспорт;
	\item используемый транспорт:
	\begin{itemize}[noitemsep]
		\item использование общей памяти - транспорт по-умолчанию;
		\item MQueue;
		\item CORBA;
		\item MQueue при помощи CORBA OOB.
	\end{itemize}
	\item размер данных;
	\item размер буферов соединений;
	\item подход к взаимодействию компонентов:
	\begin{itemize}[noitemsep]
		\item используя порты;
		\item используя вызов операций;
		\item используя сервисы.
	\end{itemize}
\end{itemize}